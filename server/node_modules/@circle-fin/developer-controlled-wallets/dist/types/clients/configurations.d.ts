import * as axios from 'axios';
import { AxiosRequestConfig, AxiosInstance, AxiosPromise } from 'axios';

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
interface ConfigurationParameters {
    apiKey?: string | Promise<string> | ((name: string) => string) | ((name: string) => Promise<string>);
    username?: string;
    password?: string;
    accessToken?: string | Promise<string> | ((name?: string, scopes?: string[]) => string) | ((name?: string, scopes?: string[]) => Promise<string>);
    basePath?: string;
    serverIndex?: number;
    baseOptions?: any;
    formDataCtor?: new () => any;
}
declare class Configuration {
    /**
     * parameter for apiKey security
     * @param name security name
     * @memberof Configuration
     */
    apiKey?: string | Promise<string> | ((name: string) => string) | ((name: string) => Promise<string>);
    /**
     * parameter for basic security
     *
     * @type {string}
     * @memberof Configuration
     */
    username?: string;
    /**
     * parameter for basic security
     *
     * @type {string}
     * @memberof Configuration
     */
    password?: string;
    /**
     * parameter for oauth2 security
     * @param name security name
     * @param scopes oauth2 scope
     * @memberof Configuration
     */
    accessToken?: string | Promise<string> | ((name?: string, scopes?: string[]) => string) | ((name?: string, scopes?: string[]) => Promise<string>);
    /**
     * override base path
     *
     * @type {string}
     * @memberof Configuration
     */
    basePath?: string;
    /**
     * override server index
     *
     * @type {number}
     * @memberof Configuration
     */
    serverIndex?: number;
    /**
     * base options for axios calls
     *
     * @type {any}
     * @memberof Configuration
     */
    baseOptions?: any;
    /**
     * The FormData constructor that will be used to create multipart form data
     * requests. You can inject this here so that execution environments that
     * do not support the FormData class can still run the generated client.
     *
     * @type {new () => FormData}
     */
    formDataCtor?: new () => any;
    constructor(param?: ConfigurationParameters);
    /**
     * Check if the given MIME is a JSON MIME.
     * JSON MIME examples:
     *   application/json
     *   application/json; charset=UTF8
     *   APPLICATION/JSON
     *   application/vnd.company+json
     * @param mime - MIME (Multipurpose Internet Mail Extensions)
     * @return True if the given MIME is JSON, false otherwise.
     */
    isJsonMime(mime: string): boolean;
}

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface RequestArgs
 */
interface RequestArgs {
    url: string;
    options: AxiosRequestConfig;
}
/**
 *
 * @export
 * @class BaseAPI
 */
declare class BaseAPI {
    protected basePath: string;
    protected axios: AxiosInstance;
    protected configuration: Configuration | undefined;
    constructor(configuration?: Configuration, basePath?: string, axios?: AxiosInstance);
}

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface BadRequestResponse
 */
interface BadRequestResponse {
    /**
     * Code that corresponds to the error.
     * @type {number}
     * @memberof BadRequestResponse
     */
    'code': number;
    /**
     * Message that describes the error.
     * @type {string}
     * @memberof BadRequestResponse
     */
    'message': string;
}

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * The blockchain network that the resource is to be created on or is currently on.
 * @export
 * @enum {string}
 */
declare const Blockchain: {
    readonly Eth: "ETH";
    readonly EthSepolia: "ETH-SEPOLIA";
    readonly Avax: "AVAX";
    readonly AvaxFuji: "AVAX-FUJI";
    readonly Matic: "MATIC";
    readonly MaticAmoy: "MATIC-AMOY";
    readonly Sol: "SOL";
    readonly SolDevnet: "SOL-DEVNET";
};
type Blockchain = typeof Blockchain[keyof typeof Blockchain];

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @enum {string}
 */
declare const TokenMonitorScope: {
    readonly Selected: "SELECTED";
    readonly MonitorAll: "MONITOR_ALL";
};
type TokenMonitorScope = typeof TokenMonitorScope[keyof typeof TokenMonitorScope];

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @enum {string}
 */
declare const TokenStandard: {
    readonly Erc20: "ERC20";
    readonly Erc721: "ERC721";
    readonly Erc1155: "ERC1155";
};
type TokenStandard = typeof TokenStandard[keyof typeof TokenStandard];

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface TokenResponse
 */
interface TokenResponse {
    /**
     * System-generated unique identifier of the resource.
     * @type {string}
     * @memberof TokenResponse
     */
    'id': string;
    /**
     * Blockchain name of the specified token.
     * @type {string}
     * @memberof TokenResponse
     */
    'name'?: string;
    /**
     *
     * @type {TokenStandard}
     * @memberof TokenResponse
     */
    'standard'?: TokenStandard;
    /**
     *
     * @type {Blockchain}
     * @memberof TokenResponse
     */
    'blockchain': Blockchain;
    /**
     * Number of decimal places shown in the token amount.
     * @type {number}
     * @memberof TokenResponse
     */
    'decimals'?: number;
    /**
     * Defines if the token is a native token of the specified blockchain. If TRUE, the token is a native token.
     * @type {boolean}
     * @memberof TokenResponse
     */
    'isNative': boolean;
    /**
     * Blockchain symbol of the specified token.
     * @type {string}
     * @memberof TokenResponse
     */
    'symbol'?: string;
    /**
     * Blockchain address of the specified token.
     * @type {string}
     * @memberof TokenResponse
     */
    'tokenAddress'?: string;
    /**
     * Date and time the resource was last updated, in ISO-8601 UTC format.
     * @type {string}
     * @memberof TokenResponse
     */
    'updateDate': string;
    /**
     * Date and time the resource was created, in ISO-8601 UTC format.
     * @type {string}
     * @memberof TokenResponse
     */
    'createDate': string;
}

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface PostMonitoredTokensResponse
 */
interface PostMonitoredTokensResponse {
    /**
     *
     * @type {TokenMonitorScope}
     * @memberof PostMonitoredTokensResponse
     */
    'scope'?: TokenMonitorScope;
    /**
     * The list of tokens that have been added to the monitored tokens list. When fetching wallet balances, only these tokens will be shown by default.
     * @type {Array<TokenResponse>}
     * @memberof PostMonitoredTokensResponse
     */
    'tokens'?: Array<TokenResponse>;
}

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface CreateMonitoredTokens200Response
 */
interface CreateMonitoredTokens200Response {
    /**
     *
     * @type {PostMonitoredTokensResponse}
     * @memberof CreateMonitoredTokens200Response
     */
    'data'?: PostMonitoredTokensResponse;
}

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * Required parameters to create a new subscription.
 * @export
 * @interface CreateSubscriptionRequest
 */
interface CreateSubscriptionRequest {
    /**
     * URL of the endpoint to subscribe to notifications. Must be publicly accessible, use HTTPS, and respond with a 2XX status to a POST request.
     * @type {string}
     * @memberof CreateSubscriptionRequest
     */
    'endpoint': string;
}

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface DeleteMonitoredTokensRequest
 */
interface DeleteMonitoredTokensRequest {
    /**
     * Token ids to be removed from the monitored tokens list. Once removed, these tokens will no longer be shown by default when fetching wallet balances.
     * @type {Array<string>}
     * @memberof DeleteMonitoredTokensRequest
     */
    'tokenIds': Array<string>;
}

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * The testnet blockchain network the resource will be created on or is currently on.
 * @export
 * @enum {string}
 */
declare const TestnetBlockchain: {
    readonly EthSepolia: "ETH-SEPOLIA";
    readonly AvaxFuji: "AVAX-FUJI";
    readonly MaticAmoy: "MATIC-AMOY";
    readonly SolDevnet: "SOL-DEVNET";
};
type TestnetBlockchain = typeof TestnetBlockchain[keyof typeof TestnetBlockchain];

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface FaucetRequest
 */
interface FaucetRequest {
    /**
     * The blockchain address generated upon wallet creation.
     * @type {string}
     * @memberof FaucetRequest
     */
    'address': string;
    /**
     *
     * @type {TestnetBlockchain}
     * @memberof FaucetRequest
     */
    'blockchain': TestnetBlockchain;
    /**
     * Request native testnet tokens.
     * @type {boolean}
     * @memberof FaucetRequest
     */
    'native'?: boolean;
    /**
     * Request USDC testnet tokens.
     * @type {boolean}
     * @memberof FaucetRequest
     */
    'usdc'?: boolean;
    /**
     * Request EURC testnet tokens.
     * @type {boolean}
     * @memberof FaucetRequest
     */
    'eurc'?: boolean;
}

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface GetEntityConfigResponse
 */
interface GetEntityConfigResponse {
    /**
     *
     * @type {string}
     * @memberof GetEntityConfigResponse
     */
    'appId'?: string;
}

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface GetEntityConfig200Response
 */
interface GetEntityConfig200Response {
    /**
     *
     * @type {GetEntityConfigResponse}
     * @memberof GetEntityConfig200Response
     */
    'data'?: GetEntityConfigResponse;
}

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface GetMonitoredTokensResponse
 */
interface GetMonitoredTokensResponse {
    /**
     *
     * @type {TokenMonitorScope}
     * @memberof GetMonitoredTokensResponse
     */
    'scope'?: TokenMonitorScope;
    /**
     * The list of tokens that are currently on the monitored tokens list. When fetching wallet balances, only these tokens will be shown by default.
     * @type {Array<TokenResponse>}
     * @memberof GetMonitoredTokensResponse
     */
    'tokens'?: Array<TokenResponse>;
}

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface NotificationSignaturePublicKey
 */
interface NotificationSignaturePublicKey {
    /**
     *
     * @type {string}
     * @memberof NotificationSignaturePublicKey
     */
    'id': string;
    /**
     *
     * @type {string}
     * @memberof NotificationSignaturePublicKey
     */
    'algorithm': string;
    /**
     *
     * @type {string}
     * @memberof NotificationSignaturePublicKey
     */
    'publicKey': string;
    /**
     *
     * @type {string}
     * @memberof NotificationSignaturePublicKey
     */
    'createDate': string;
}

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface GetNotificationSignature
 */
interface GetNotificationSignature {
    /**
     *
     * @type {NotificationSignaturePublicKey}
     * @memberof GetNotificationSignature
     */
    'data'?: NotificationSignaturePublicKey;
}

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface GetPublicKeyResponse
 */
interface GetPublicKeyResponse {
    /**
     *
     * @type {string}
     * @memberof GetPublicKeyResponse
     */
    'publicKey'?: string;
}

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface GetPublicKey200Response
 */
interface GetPublicKey200Response {
    /**
     *
     * @type {GetPublicKeyResponse}
     * @memberof GetPublicKey200Response
     */
    'data'?: GetPublicKeyResponse;
}

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface Status
 */
interface Status {
    /**
     *
     * @type {string}
     * @memberof Status
     */
    'version'?: string;
    /**
     *
     * @type {string}
     * @memberof Status
     */
    'message'?: string;
}

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface ListMonitoredTokens200ResponseResponse
 */
interface ListMonitoredTokens200ResponseResponse {
    /**
     *
     * @type {Status}
     * @memberof ListMonitoredTokens200ResponseResponse
     */
    'status'?: Status;
    /**
     *
     * @type {GetMonitoredTokensResponse}
     * @memberof ListMonitoredTokens200ResponseResponse
     */
    'data'?: GetMonitoredTokensResponse;
}

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface ListMonitoredTokens200Response
 */
interface ListMonitoredTokens200Response {
    /**
     *
     * @type {ListMonitoredTokens200ResponseResponse}
     * @memberof ListMonitoredTokens200Response
     */
    'response'?: ListMonitoredTokens200ResponseResponse;
}

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface ModelError
 */
interface ModelError {
    /**
     * Code is the error code
     * @type {number}
     * @memberof ModelError
     */
    'code'?: number;
    /**
     * Message is the error message
     * @type {string}
     * @memberof ModelError
     */
    'message'?: string;
}

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface NotAuthorizedResponse
 */
interface NotAuthorizedResponse {
    /**
     * Code that corresponds to the error.
     * @type {number}
     * @memberof NotAuthorizedResponse
     */
    'code': number;
    /**
     * Message that describes the error.
     * @type {string}
     * @memberof NotAuthorizedResponse
     */
    'message': string;
}

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface NotFoundResponse
 */
interface NotFoundResponse {
    /**
     * Code that corresponds to the error.
     * @type {number}
     * @memberof NotFoundResponse
     */
    'code': number;
    /**
     * Message that describes the error.
     * @type {string}
     * @memberof NotFoundResponse
     */
    'message': string;
}

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface Ping
 */
interface Ping {
    /**
     * Response to a ping.
     * @type {string}
     * @memberof Ping
     */
    'message': string;
}

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface PostMonitoredTokensRequest
 */
interface PostMonitoredTokensRequest {
    /**
     * The list of tokens to add to the monitored tokens list. When fetching wallet balances, only these tokens will be shown by default.
     * @type {Array<string>}
     * @memberof PostMonitoredTokensRequest
     */
    'tokenIds': Array<string>;
}

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface PutMonitoredTokensRequest
 */
interface PutMonitoredTokensRequest {
    /**
     * The list of tokens that will be added to the monitored tokens list. When fetching wallet balances, these tokens will be shown by default.
     * @type {Array<string>}
     * @memberof PutMonitoredTokensRequest
     */
    'tokenIds'?: Array<string>;
}

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface PutMonitoredTokensResponse
 */
interface PutMonitoredTokensResponse {
    /**
     *
     * @type {TokenMonitorScope}
     * @memberof PutMonitoredTokensResponse
     */
    'scope'?: TokenMonitorScope;
    /**
     * The list of tokens that have been added to the monitored tokens list. When fetching wallet balances, these tokens will be shown by default.
     * @type {Array<TokenResponse>}
     * @memberof PutMonitoredTokensResponse
     */
    'tokens'?: Array<TokenResponse>;
}

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface PutMonitoredTokensScopeRequest
 */
interface PutMonitoredTokensScopeRequest {
    /**
     *
     * @type {TokenMonitorScope}
     * @memberof PutMonitoredTokensScopeRequest
     */
    'scope': TokenMonitorScope;
}

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * Contains information about a webhook notification subscription.
 * @export
 * @interface Subscription
 */
interface Subscription {
    /**
     * System-generated unique identifier of the resource.
     * @type {string}
     * @memberof Subscription
     */
    'id': string;
    /**
     * Name of the webhook notification subscription.
     * @type {string}
     * @memberof Subscription
     */
    'name': string;
    /**
     * URL of the endpoint subscribing to notifications. Must be enabled to receive notifications.
     * @type {string}
     * @memberof Subscription
     */
    'endpoint': string;
    /**
     * Whether the subscription is enabled. `true` indicates the subscription is enabled.
     * @type {boolean}
     * @memberof Subscription
     */
    'enabled': boolean;
    /**
     * Date and time the resource was created, in ISO-8601 UTC format.
     * @type {string}
     * @memberof Subscription
     */
    'createDate': string;
    /**
     * Date and time the resource was last updated, in ISO-8601 UTC format.
     * @type {string}
     * @memberof Subscription
     */
    'updateDate': string;
}

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface Subscription2
 */
interface Subscription2 {
    /**
     *
     * @type {Subscription}
     * @memberof Subscription2
     */
    'data'?: Subscription;
}

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface Subscriptions
 */
interface Subscriptions {
    /**
     *
     * @type {Array<Subscription>}
     * @memberof Subscriptions
     */
    'data'?: Array<Subscription>;
}

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface UpdateMonitoredTokens200Response
 */
interface UpdateMonitoredTokens200Response {
    /**
     *
     * @type {PutMonitoredTokensResponse}
     * @memberof UpdateMonitoredTokens200Response
     */
    'data'?: PutMonitoredTokensResponse;
}

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface UpdateSubscriptionRequest
 */
interface UpdateSubscriptionRequest {
    /**
     * Name of the subscription.
     * @type {string}
     * @memberof UpdateSubscriptionRequest
     */
    'name': string;
    /**
     * Whether the subscription is enabled. `true` indicates the subscription is active.
     * @type {boolean}
     * @memberof UpdateSubscriptionRequest
     */
    'enabled': boolean;
}

/**
 * DeveloperAccountApi - axios parameter creator
 * @export
 */
declare const DeveloperAccountApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Get the app ID associated to the entity.
     * @summary Get configuration for entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEntityConfig: (options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get the public key associated with the entity.
     * @summary Get public key for entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPublicKey: (options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * DeveloperAccountApi - functional programming interface
 * @export
 */
declare const DeveloperAccountApiFp: (configuration?: Configuration) => {
    /**
     * Get the app ID associated to the entity.
     * @summary Get configuration for entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEntityConfig(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetEntityConfig200Response>>;
    /**
     * Get the public key associated with the entity.
     * @summary Get public key for entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPublicKey(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPublicKey200Response>>;
};
/**
 * DeveloperAccountApi - factory interface
 * @export
 */
declare const DeveloperAccountApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Get the app ID associated to the entity.
     * @summary Get configuration for entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEntityConfig(options?: any): AxiosPromise<GetEntityConfig200Response>;
    /**
     * Get the public key associated with the entity.
     * @summary Get public key for entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPublicKey(options?: any): AxiosPromise<GetPublicKey200Response>;
};
/**
 * DeveloperAccountApi - object-oriented interface
 * @export
 * @class DeveloperAccountApi
 * @extends {BaseAPI}
 */
declare class DeveloperAccountApi extends BaseAPI {
    /**
     * Get the app ID associated to the entity.
     * @summary Get configuration for entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeveloperAccountApi
     */
    getEntityConfig(options?: AxiosRequestConfig): Promise<axios.AxiosResponse<GetEntityConfig200Response, any>>;
    /**
     * Get the public key associated with the entity.
     * @summary Get public key for entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeveloperAccountApi
     */
    getPublicKey(options?: AxiosRequestConfig): Promise<axios.AxiosResponse<GetPublicKey200Response, any>>;
}

/**
 * FaucetApi - axios parameter creator
 * @export
 */
declare const FaucetApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Request testnet tokens for your wallet.
     * @summary Request testnet tokens
     * @param {string} [xRequestId] Developer-provided parameter used to identify this request. Useful when communicating with Circle Support.
     * @param {FaucetRequest} [faucetRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestTestnetTokens: (xRequestId?: string, faucetRequest?: FaucetRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * FaucetApi - functional programming interface
 * @export
 */
declare const FaucetApiFp: (configuration?: Configuration) => {
    /**
     * Request testnet tokens for your wallet.
     * @summary Request testnet tokens
     * @param {string} [xRequestId] Developer-provided parameter used to identify this request. Useful when communicating with Circle Support.
     * @param {FaucetRequest} [faucetRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestTestnetTokens(xRequestId?: string, faucetRequest?: FaucetRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
};
/**
 * FaucetApi - factory interface
 * @export
 */
declare const FaucetApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Request testnet tokens for your wallet.
     * @summary Request testnet tokens
     * @param {string} [xRequestId] Developer-provided parameter used to identify this request. Useful when communicating with Circle Support.
     * @param {FaucetRequest} [faucetRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestTestnetTokens(xRequestId?: string, faucetRequest?: FaucetRequest, options?: any): AxiosPromise<void>;
};
/**
 * FaucetApi - object-oriented interface
 * @export
 * @class FaucetApi
 * @extends {BaseAPI}
 */
declare class FaucetApi extends BaseAPI {
    /**
     * Request testnet tokens for your wallet.
     * @summary Request testnet tokens
     * @param {string} [xRequestId] Developer-provided parameter used to identify this request. Useful when communicating with Circle Support.
     * @param {FaucetRequest} [faucetRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FaucetApi
     */
    requestTestnetTokens(xRequestId?: string, faucetRequest?: FaucetRequest, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<void, any>>;
}

/**
 * HealthApi - axios parameter creator
 * @export
 */
declare const HealthApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Checks that the service is running.
     * @summary Ping
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ping: (options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * HealthApi - functional programming interface
 * @export
 */
declare const HealthApiFp: (configuration?: Configuration) => {
    /**
     * Checks that the service is running.
     * @summary Ping
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ping(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Ping>>;
};
/**
 * HealthApi - factory interface
 * @export
 */
declare const HealthApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Checks that the service is running.
     * @summary Ping
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ping(options?: any): AxiosPromise<Ping>;
};
/**
 * HealthApi - object-oriented interface
 * @export
 * @class HealthApi
 * @extends {BaseAPI}
 */
declare class HealthApi extends BaseAPI {
    /**
     * Checks that the service is running.
     * @summary Ping
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    ping(options?: AxiosRequestConfig): Promise<axios.AxiosResponse<Ping, any>>;
}

/**
 * MonitorTokensApi - axios parameter creator
 * @export
 */
declare const MonitorTokensApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Add a new token to the monitored token list.
     * @summary Set monitored tokens
     * @param {PostMonitoredTokensRequest} postMonitoredTokensRequest Request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createMonitoredTokens: (postMonitoredTokensRequest: PostMonitoredTokensRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Delete tokens from the monitored token list.
     * @summary Delete monitored tokens
     * @param {DeleteMonitoredTokensRequest} deleteMonitoredTokensRequest Request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteMonitoredTokens: (deleteMonitoredTokensRequest: DeleteMonitoredTokensRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get monitored tokens
     * @summary Retreive existing monitored tokens.
     * @param {Blockchain} [blockchain] Filter by blockchain.
     * @param {string} [tokenAddress]
     * @param {string} [symbol]
     * @param {string} [from] Queries items created since the specified date-time (inclusive) in ISO 8601 format.
     * @param {string} [to] Queries items created before the specified date-time (inclusive) in ISO 8601 format.
     * @param {string} [pageBefore] A collection ID value used for pagination.  It marks the exclusive end of a page. When provided, the collection resource will return the next n items before the id, with n being specified by pageSize.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither pageAfter nor pageBefore are specified.   SHOULD NOT be used in conjunction with pageAfter.
     * @param {string} [pageAfter] A collection ID value used for pagination.  It marks the exclusive begin of a page. When provided, the collection resource will return the next n items after the id, with n being specified by pageSize.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither pageAfter nor pageBefore are specified.  SHOULD NOT be used in conjunction with pageBefore.
     * @param {number} [pageSize] Limits the number of items to be returned.  Some collections have a strict upper bound that will disregard this value. In case the specified value is higher than the allowed limit, the collection limit will be used.  If avoided, the collection will determine the page size itself.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listMonitoredTokens: (blockchain?: Blockchain, tokenAddress?: string, symbol?: string, from?: string, to?: string, pageBefore?: string, pageAfter?: string, pageSize?: number, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Edit the monitored token list.
     * @summary Update monitored tokens
     * @param {PutMonitoredTokensRequest} putMonitoredTokensRequest Request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateMonitoredTokens: (putMonitoredTokensRequest: PutMonitoredTokensRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Select between monitoring all tokens or selected tokens added to the monitored tokens list.
     * @summary Update monitored tokens scope
     * @param {PutMonitoredTokensScopeRequest} putMonitoredTokensScopeRequest Request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateMonitoredTokensScope: (putMonitoredTokensScopeRequest: PutMonitoredTokensScopeRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * MonitorTokensApi - functional programming interface
 * @export
 */
declare const MonitorTokensApiFp: (configuration?: Configuration) => {
    /**
     * Add a new token to the monitored token list.
     * @summary Set monitored tokens
     * @param {PostMonitoredTokensRequest} postMonitoredTokensRequest Request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createMonitoredTokens(postMonitoredTokensRequest: PostMonitoredTokensRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateMonitoredTokens200Response>>;
    /**
     * Delete tokens from the monitored token list.
     * @summary Delete monitored tokens
     * @param {DeleteMonitoredTokensRequest} deleteMonitoredTokensRequest Request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteMonitoredTokens(deleteMonitoredTokensRequest: DeleteMonitoredTokensRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Get monitored tokens
     * @summary Retreive existing monitored tokens.
     * @param {Blockchain} [blockchain] Filter by blockchain.
     * @param {string} [tokenAddress]
     * @param {string} [symbol]
     * @param {string} [from] Queries items created since the specified date-time (inclusive) in ISO 8601 format.
     * @param {string} [to] Queries items created before the specified date-time (inclusive) in ISO 8601 format.
     * @param {string} [pageBefore] A collection ID value used for pagination.  It marks the exclusive end of a page. When provided, the collection resource will return the next n items before the id, with n being specified by pageSize.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither pageAfter nor pageBefore are specified.   SHOULD NOT be used in conjunction with pageAfter.
     * @param {string} [pageAfter] A collection ID value used for pagination.  It marks the exclusive begin of a page. When provided, the collection resource will return the next n items after the id, with n being specified by pageSize.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither pageAfter nor pageBefore are specified.  SHOULD NOT be used in conjunction with pageBefore.
     * @param {number} [pageSize] Limits the number of items to be returned.  Some collections have a strict upper bound that will disregard this value. In case the specified value is higher than the allowed limit, the collection limit will be used.  If avoided, the collection will determine the page size itself.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listMonitoredTokens(blockchain?: Blockchain, tokenAddress?: string, symbol?: string, from?: string, to?: string, pageBefore?: string, pageAfter?: string, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListMonitoredTokens200Response>>;
    /**
     * Edit the monitored token list.
     * @summary Update monitored tokens
     * @param {PutMonitoredTokensRequest} putMonitoredTokensRequest Request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateMonitoredTokens(putMonitoredTokensRequest: PutMonitoredTokensRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateMonitoredTokens200Response>>;
    /**
     * Select between monitoring all tokens or selected tokens added to the monitored tokens list.
     * @summary Update monitored tokens scope
     * @param {PutMonitoredTokensScopeRequest} putMonitoredTokensScopeRequest Request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateMonitoredTokensScope(putMonitoredTokensScopeRequest: PutMonitoredTokensScopeRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
};
/**
 * MonitorTokensApi - factory interface
 * @export
 */
declare const MonitorTokensApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Add a new token to the monitored token list.
     * @summary Set monitored tokens
     * @param {PostMonitoredTokensRequest} postMonitoredTokensRequest Request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createMonitoredTokens(postMonitoredTokensRequest: PostMonitoredTokensRequest, options?: any): AxiosPromise<CreateMonitoredTokens200Response>;
    /**
     * Delete tokens from the monitored token list.
     * @summary Delete monitored tokens
     * @param {DeleteMonitoredTokensRequest} deleteMonitoredTokensRequest Request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteMonitoredTokens(deleteMonitoredTokensRequest: DeleteMonitoredTokensRequest, options?: any): AxiosPromise<void>;
    /**
     * Get monitored tokens
     * @summary Retreive existing monitored tokens.
     * @param {Blockchain} [blockchain] Filter by blockchain.
     * @param {string} [tokenAddress]
     * @param {string} [symbol]
     * @param {string} [from] Queries items created since the specified date-time (inclusive) in ISO 8601 format.
     * @param {string} [to] Queries items created before the specified date-time (inclusive) in ISO 8601 format.
     * @param {string} [pageBefore] A collection ID value used for pagination.  It marks the exclusive end of a page. When provided, the collection resource will return the next n items before the id, with n being specified by pageSize.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither pageAfter nor pageBefore are specified.   SHOULD NOT be used in conjunction with pageAfter.
     * @param {string} [pageAfter] A collection ID value used for pagination.  It marks the exclusive begin of a page. When provided, the collection resource will return the next n items after the id, with n being specified by pageSize.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither pageAfter nor pageBefore are specified.  SHOULD NOT be used in conjunction with pageBefore.
     * @param {number} [pageSize] Limits the number of items to be returned.  Some collections have a strict upper bound that will disregard this value. In case the specified value is higher than the allowed limit, the collection limit will be used.  If avoided, the collection will determine the page size itself.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listMonitoredTokens(blockchain?: Blockchain, tokenAddress?: string, symbol?: string, from?: string, to?: string, pageBefore?: string, pageAfter?: string, pageSize?: number, options?: any): AxiosPromise<ListMonitoredTokens200Response>;
    /**
     * Edit the monitored token list.
     * @summary Update monitored tokens
     * @param {PutMonitoredTokensRequest} putMonitoredTokensRequest Request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateMonitoredTokens(putMonitoredTokensRequest: PutMonitoredTokensRequest, options?: any): AxiosPromise<UpdateMonitoredTokens200Response>;
    /**
     * Select between monitoring all tokens or selected tokens added to the monitored tokens list.
     * @summary Update monitored tokens scope
     * @param {PutMonitoredTokensScopeRequest} putMonitoredTokensScopeRequest Request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateMonitoredTokensScope(putMonitoredTokensScopeRequest: PutMonitoredTokensScopeRequest, options?: any): AxiosPromise<void>;
};
/**
 * MonitorTokensApi - object-oriented interface
 * @export
 * @class MonitorTokensApi
 * @extends {BaseAPI}
 */
declare class MonitorTokensApi extends BaseAPI {
    /**
     * Add a new token to the monitored token list.
     * @summary Set monitored tokens
     * @param {PostMonitoredTokensRequest} postMonitoredTokensRequest Request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MonitorTokensApi
     */
    createMonitoredTokens(postMonitoredTokensRequest: PostMonitoredTokensRequest, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<CreateMonitoredTokens200Response, any>>;
    /**
     * Delete tokens from the monitored token list.
     * @summary Delete monitored tokens
     * @param {DeleteMonitoredTokensRequest} deleteMonitoredTokensRequest Request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MonitorTokensApi
     */
    deleteMonitoredTokens(deleteMonitoredTokensRequest: DeleteMonitoredTokensRequest, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<void, any>>;
    /**
     * Get monitored tokens
     * @summary Retreive existing monitored tokens.
     * @param {Blockchain} [blockchain] Filter by blockchain.
     * @param {string} [tokenAddress]
     * @param {string} [symbol]
     * @param {string} [from] Queries items created since the specified date-time (inclusive) in ISO 8601 format.
     * @param {string} [to] Queries items created before the specified date-time (inclusive) in ISO 8601 format.
     * @param {string} [pageBefore] A collection ID value used for pagination.  It marks the exclusive end of a page. When provided, the collection resource will return the next n items before the id, with n being specified by pageSize.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither pageAfter nor pageBefore are specified.   SHOULD NOT be used in conjunction with pageAfter.
     * @param {string} [pageAfter] A collection ID value used for pagination.  It marks the exclusive begin of a page. When provided, the collection resource will return the next n items after the id, with n being specified by pageSize.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither pageAfter nor pageBefore are specified.  SHOULD NOT be used in conjunction with pageBefore.
     * @param {number} [pageSize] Limits the number of items to be returned.  Some collections have a strict upper bound that will disregard this value. In case the specified value is higher than the allowed limit, the collection limit will be used.  If avoided, the collection will determine the page size itself.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MonitorTokensApi
     */
    listMonitoredTokens(blockchain?: Blockchain, tokenAddress?: string, symbol?: string, from?: string, to?: string, pageBefore?: string, pageAfter?: string, pageSize?: number, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<ListMonitoredTokens200Response, any>>;
    /**
     * Edit the monitored token list.
     * @summary Update monitored tokens
     * @param {PutMonitoredTokensRequest} putMonitoredTokensRequest Request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MonitorTokensApi
     */
    updateMonitoredTokens(putMonitoredTokensRequest: PutMonitoredTokensRequest, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<UpdateMonitoredTokens200Response, any>>;
    /**
     * Select between monitoring all tokens or selected tokens added to the monitored tokens list.
     * @summary Update monitored tokens scope
     * @param {PutMonitoredTokensScopeRequest} putMonitoredTokensScopeRequest Request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MonitorTokensApi
     */
    updateMonitoredTokensScope(putMonitoredTokensScopeRequest: PutMonitoredTokensScopeRequest, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<void, any>>;
}

/**
 * WebhookSubscriptionsApi - axios parameter creator
 * @export
 */
declare const WebhookSubscriptionsApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Create a notification subscription by configuring an endpoint to receive notifications. For details, see the [Notification Flows](https://developers.circle.com/w3s/docs/notification-flows) guide.
     * @summary Create a notification subscription
     * @param {CreateSubscriptionRequest} createSubscriptionRequest Schema for the request payload to create a new subscription.
     * @param {string} [xRequestId] Developer-provided parameter used to identify this request. Useful when communicating with Circle Support.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSubscription: (createSubscriptionRequest: CreateSubscriptionRequest, xRequestId?: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Delete an existing subscription.
     * @summary Delete a notification subscription
     * @param {string} id The universally unique identifier (UUID v4) of the resource.
     * @param {string} [xRequestId] Developer-provided parameter used to identify this request. Useful when communicating with Circle Support.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSubscription: (id: string, xRequestId?: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get the public key and algorithm used to digitally sign webhook notifications. Verifying the digital signature ensures the notification came from Circle.  In the headers of each webhook, you can find   1. `X-Circle-Signature`: a header containing the digital signature generated by Circle.   2. `X-Circle-Key-Id`: a header containing the UUID. This is will be used as the `ID` as URL parameter to retrieve the relevant public key.
     * @summary Get a notification signature public key
     * @param {string} id Universally unique identifier (UUID v4) of a resource.
     * @param {string} [xRequestId] Developer-provided parameter used to identify this request. Useful when communicating with Circle Support.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNotificationSignature: (id: string, xRequestId?: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Retrieve an existing notification subscription.
     * @summary Retrieve a notification subscription
     * @param {string} id The universally unique identifier (UUID v4) of the resource.
     * @param {string} [xRequestId] Developer-provided parameter used to identify this request. Useful when communicating with Circle Support.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSubscription: (id: string, xRequestId?: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Retrieve an array of existing notification subscriptions.
     * @summary Get all notification subscriptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSubscriptions: (options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Update subscription endpoint to receive notifications.
     * @summary Update a notification subscription
     * @param {string} id The universally unique identifier (UUID v4) of the resource.
     * @param {UpdateSubscriptionRequest} updateSubscriptionRequest Schema for the request payload to update a new subscription.
     * @param {string} [xRequestId] Developer-provided parameter used to identify this request. Useful when communicating with Circle Support.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateSubscription: (id: string, updateSubscriptionRequest: UpdateSubscriptionRequest, xRequestId?: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * WebhookSubscriptionsApi - functional programming interface
 * @export
 */
declare const WebhookSubscriptionsApiFp: (configuration?: Configuration) => {
    /**
     * Create a notification subscription by configuring an endpoint to receive notifications. For details, see the [Notification Flows](https://developers.circle.com/w3s/docs/notification-flows) guide.
     * @summary Create a notification subscription
     * @param {CreateSubscriptionRequest} createSubscriptionRequest Schema for the request payload to create a new subscription.
     * @param {string} [xRequestId] Developer-provided parameter used to identify this request. Useful when communicating with Circle Support.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSubscription(createSubscriptionRequest: CreateSubscriptionRequest, xRequestId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subscription2>>;
    /**
     * Delete an existing subscription.
     * @summary Delete a notification subscription
     * @param {string} id The universally unique identifier (UUID v4) of the resource.
     * @param {string} [xRequestId] Developer-provided parameter used to identify this request. Useful when communicating with Circle Support.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSubscription(id: string, xRequestId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Get the public key and algorithm used to digitally sign webhook notifications. Verifying the digital signature ensures the notification came from Circle.  In the headers of each webhook, you can find   1. `X-Circle-Signature`: a header containing the digital signature generated by Circle.   2. `X-Circle-Key-Id`: a header containing the UUID. This is will be used as the `ID` as URL parameter to retrieve the relevant public key.
     * @summary Get a notification signature public key
     * @param {string} id Universally unique identifier (UUID v4) of a resource.
     * @param {string} [xRequestId] Developer-provided parameter used to identify this request. Useful when communicating with Circle Support.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNotificationSignature(id: string, xRequestId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetNotificationSignature>>;
    /**
     * Retrieve an existing notification subscription.
     * @summary Retrieve a notification subscription
     * @param {string} id The universally unique identifier (UUID v4) of the resource.
     * @param {string} [xRequestId] Developer-provided parameter used to identify this request. Useful when communicating with Circle Support.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSubscription(id: string, xRequestId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subscription2>>;
    /**
     * Retrieve an array of existing notification subscriptions.
     * @summary Get all notification subscriptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSubscriptions(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subscriptions>>;
    /**
     * Update subscription endpoint to receive notifications.
     * @summary Update a notification subscription
     * @param {string} id The universally unique identifier (UUID v4) of the resource.
     * @param {UpdateSubscriptionRequest} updateSubscriptionRequest Schema for the request payload to update a new subscription.
     * @param {string} [xRequestId] Developer-provided parameter used to identify this request. Useful when communicating with Circle Support.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateSubscription(id: string, updateSubscriptionRequest: UpdateSubscriptionRequest, xRequestId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subscription2>>;
};
/**
 * WebhookSubscriptionsApi - factory interface
 * @export
 */
declare const WebhookSubscriptionsApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Create a notification subscription by configuring an endpoint to receive notifications. For details, see the [Notification Flows](https://developers.circle.com/w3s/docs/notification-flows) guide.
     * @summary Create a notification subscription
     * @param {CreateSubscriptionRequest} createSubscriptionRequest Schema for the request payload to create a new subscription.
     * @param {string} [xRequestId] Developer-provided parameter used to identify this request. Useful when communicating with Circle Support.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSubscription(createSubscriptionRequest: CreateSubscriptionRequest, xRequestId?: string, options?: any): AxiosPromise<Subscription2>;
    /**
     * Delete an existing subscription.
     * @summary Delete a notification subscription
     * @param {string} id The universally unique identifier (UUID v4) of the resource.
     * @param {string} [xRequestId] Developer-provided parameter used to identify this request. Useful when communicating with Circle Support.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSubscription(id: string, xRequestId?: string, options?: any): AxiosPromise<void>;
    /**
     * Get the public key and algorithm used to digitally sign webhook notifications. Verifying the digital signature ensures the notification came from Circle.  In the headers of each webhook, you can find   1. `X-Circle-Signature`: a header containing the digital signature generated by Circle.   2. `X-Circle-Key-Id`: a header containing the UUID. This is will be used as the `ID` as URL parameter to retrieve the relevant public key.
     * @summary Get a notification signature public key
     * @param {string} id Universally unique identifier (UUID v4) of a resource.
     * @param {string} [xRequestId] Developer-provided parameter used to identify this request. Useful when communicating with Circle Support.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNotificationSignature(id: string, xRequestId?: string, options?: any): AxiosPromise<GetNotificationSignature>;
    /**
     * Retrieve an existing notification subscription.
     * @summary Retrieve a notification subscription
     * @param {string} id The universally unique identifier (UUID v4) of the resource.
     * @param {string} [xRequestId] Developer-provided parameter used to identify this request. Useful when communicating with Circle Support.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSubscription(id: string, xRequestId?: string, options?: any): AxiosPromise<Subscription2>;
    /**
     * Retrieve an array of existing notification subscriptions.
     * @summary Get all notification subscriptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSubscriptions(options?: any): AxiosPromise<Subscriptions>;
    /**
     * Update subscription endpoint to receive notifications.
     * @summary Update a notification subscription
     * @param {string} id The universally unique identifier (UUID v4) of the resource.
     * @param {UpdateSubscriptionRequest} updateSubscriptionRequest Schema for the request payload to update a new subscription.
     * @param {string} [xRequestId] Developer-provided parameter used to identify this request. Useful when communicating with Circle Support.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateSubscription(id: string, updateSubscriptionRequest: UpdateSubscriptionRequest, xRequestId?: string, options?: any): AxiosPromise<Subscription2>;
};
/**
 * WebhookSubscriptionsApi - object-oriented interface
 * @export
 * @class WebhookSubscriptionsApi
 * @extends {BaseAPI}
 */
declare class WebhookSubscriptionsApi extends BaseAPI {
    /**
     * Create a notification subscription by configuring an endpoint to receive notifications. For details, see the [Notification Flows](https://developers.circle.com/w3s/docs/notification-flows) guide.
     * @summary Create a notification subscription
     * @param {CreateSubscriptionRequest} createSubscriptionRequest Schema for the request payload to create a new subscription.
     * @param {string} [xRequestId] Developer-provided parameter used to identify this request. Useful when communicating with Circle Support.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookSubscriptionsApi
     */
    createSubscription(createSubscriptionRequest: CreateSubscriptionRequest, xRequestId?: string, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<Subscription2, any>>;
    /**
     * Delete an existing subscription.
     * @summary Delete a notification subscription
     * @param {string} id The universally unique identifier (UUID v4) of the resource.
     * @param {string} [xRequestId] Developer-provided parameter used to identify this request. Useful when communicating with Circle Support.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookSubscriptionsApi
     */
    deleteSubscription(id: string, xRequestId?: string, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<void, any>>;
    /**
     * Get the public key and algorithm used to digitally sign webhook notifications. Verifying the digital signature ensures the notification came from Circle.  In the headers of each webhook, you can find   1. `X-Circle-Signature`: a header containing the digital signature generated by Circle.   2. `X-Circle-Key-Id`: a header containing the UUID. This is will be used as the `ID` as URL parameter to retrieve the relevant public key.
     * @summary Get a notification signature public key
     * @param {string} id Universally unique identifier (UUID v4) of a resource.
     * @param {string} [xRequestId] Developer-provided parameter used to identify this request. Useful when communicating with Circle Support.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookSubscriptionsApi
     */
    getNotificationSignature(id: string, xRequestId?: string, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<GetNotificationSignature, any>>;
    /**
     * Retrieve an existing notification subscription.
     * @summary Retrieve a notification subscription
     * @param {string} id The universally unique identifier (UUID v4) of the resource.
     * @param {string} [xRequestId] Developer-provided parameter used to identify this request. Useful when communicating with Circle Support.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookSubscriptionsApi
     */
    getSubscription(id: string, xRequestId?: string, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<Subscription2, any>>;
    /**
     * Retrieve an array of existing notification subscriptions.
     * @summary Get all notification subscriptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookSubscriptionsApi
     */
    getSubscriptions(options?: AxiosRequestConfig): Promise<axios.AxiosResponse<Subscriptions, any>>;
    /**
     * Update subscription endpoint to receive notifications.
     * @summary Update a notification subscription
     * @param {string} id The universally unique identifier (UUID v4) of the resource.
     * @param {UpdateSubscriptionRequest} updateSubscriptionRequest Schema for the request payload to update a new subscription.
     * @param {string} [xRequestId] Developer-provided parameter used to identify this request. Useful when communicating with Circle Support.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookSubscriptionsApi
     */
    updateSubscription(id: string, updateSubscriptionRequest: UpdateSubscriptionRequest, xRequestId?: string, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<Subscription2, any>>;
}

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

interface ClientConfig {
    /**
     * ApiKey that will be used to authenticate the request
     */
    apiKey: string;
    /**
     * Version of the client. Will be added to the user agent.
     */
    version: string;
    /**
     * Customized user agent. Will be added to the user agent.
     */
    userAgent?: string;
}
declare class ConfigurationsClient {
    DeveloperAccount: ReturnType<typeof DeveloperAccountApiFactory>;
    Faucet: ReturnType<typeof FaucetApiFactory>;
    Health: ReturnType<typeof HealthApiFactory>;
    MonitorTokens: ReturnType<typeof MonitorTokensApiFactory>;
    WebhookSubscriptions: ReturnType<typeof WebhookSubscriptionsApiFactory>;
    constructor(baseUrl: string, config: ClientConfig, headers?: Record<string, string>);
}

export { type BadRequestResponse, Blockchain, ConfigurationsClient, type CreateMonitoredTokens200Response, type CreateSubscriptionRequest, type DeleteMonitoredTokensRequest, DeveloperAccountApi, DeveloperAccountApiAxiosParamCreator, DeveloperAccountApiFactory, DeveloperAccountApiFp, FaucetApi, FaucetApiAxiosParamCreator, FaucetApiFactory, FaucetApiFp, type FaucetRequest, type GetEntityConfig200Response, type GetEntityConfigResponse, type GetMonitoredTokensResponse, type GetNotificationSignature, type GetPublicKey200Response, type GetPublicKeyResponse, HealthApi, HealthApiAxiosParamCreator, HealthApiFactory, HealthApiFp, type ListMonitoredTokens200Response, type ListMonitoredTokens200ResponseResponse, type ModelError, MonitorTokensApi, MonitorTokensApiAxiosParamCreator, MonitorTokensApiFactory, MonitorTokensApiFp, type NotAuthorizedResponse, type NotFoundResponse, type NotificationSignaturePublicKey, type Ping, type PostMonitoredTokensRequest, type PostMonitoredTokensResponse, type PutMonitoredTokensRequest, type PutMonitoredTokensResponse, type PutMonitoredTokensScopeRequest, type Status, type Subscription, type Subscription2, type Subscriptions, TestnetBlockchain, TokenMonitorScope, type TokenResponse, TokenStandard, type UpdateMonitoredTokens200Response, type UpdateSubscriptionRequest, WebhookSubscriptionsApi, WebhookSubscriptionsApiAxiosParamCreator, WebhookSubscriptionsApiFactory, WebhookSubscriptionsApiFp };
